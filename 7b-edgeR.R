set.seed("3112")

###################
## Load the data ##
###################

#Read the count matrix generated by HTSEQ-counts
rawdata=read.table("gene_read_counts_table_D21.tsv", header=TRUE, stringsAsFactors=FALSE, row.names=1)
head(rawdata)

#Check dimensions
dim(rawdata)

# Require at least 25% of samples to have count > 5
quant <- apply(rawdata,1,quantile,0.75)
keep <- which((quant >= 5) == 1)

rawdata <- rawdata[keep,]
dim(rawdata)

#Make class labels. This is used to inform edgeR of the experimental design. In this case, we are telling edgeR that the first three samples are UHR and the last three are HBR.
class <- factor( c( rep("8AM-C",3), rep("12PM-C",3), rep("4PM-C",3), rep("8PM-C",3), rep("0AM-C",3), rep("4AM-C",3), rep("8AM-S",3), rep("12PM-S",3), rep("4PM-S",3), rep("8PM-S",3), rep("0AM-S",2), rep("4AM-S",3)))

## Next step is creating a DGEList to store the expression matrix, name of the genes, and the experimental design

# Make DGEList object
y <- DGEList(counts=rawdata, genes=genes, group=class)
dim(y)

#####################
### Normalization ###  
#####################

# The TMM normalization is applied to account for the compositional biases between the libraries:**

y <- calcNormFactors(y)
y$samples    

# Calculate the normalized counts (CPM)
normalized_counts <- cpm(y, normalized.lib.sizes=TRUE)

# Convert the matrix to a data frame for easier handling and viewing
normalized_counts_df <- as.data.frame(normalized_counts)

# Add gene names as a column
normalized_counts_df$gene <- rownames(normalized_counts_df)

# Save the normalized count matrix to a file
write.table(normalized_counts_df, "Normalized_counts_matrix.tsv", sep="\t", quote=FALSE, row.names=FALSE)

# Display the head of the normalized count matrix
head(normalized_counts_df)


########################
### Data exploration ###
########################

# Checking the values of the library' sizes from all the six samples:
barplot(y$samples$lib.size*1e-6, names=1:35, ylab="Library size (millions)")

# An MDS plot shows the relative similarities of the six samples.
MDS <- plotMDS(y)


#######################################
### Differential expression analysis ##
#######################################

# Estimating the dispersion of the data

y <- estimateCommonDisp(y, verbose=TRUE)
y <- estimateTagwiseDisp(y)


# Differential expression test
et <- exactTest(y, pair=c("8AM-C","8AM-S")) #DE test between 8AM Control and 8AM Salt-treated

# The topTags function returns the top n genes with the lowest p-values. The adjust.method argument specifies the method used to adjust the p-values for multiple testing. The p.value argument specifies the p-value threshold for the results. The default is 0.05.
topTags(et, n = 10, adjust.method = "fdr", sort.by = "PValue", p.value = 1)

#Store the information of all genes within the topTags object as a data frame
x=as.data.frame(topTags(et, n = nrow(et), adjust.method = "fdr", sort.by = "PValue", p.value = 1))

# Select significant genes at FDR = 0.05
deg <- decideTestsDGE(et, p=0.05)

# summarize the results, counting the number of genes that are up- or down-regulated
summary(deg)

# Store the names of the differentially expressed genes in a vector
detags <- rownames(y)[as.logical(deg)]

############################################################
### Visualization of the differential expression results ###
############################################################

#Plot log-fold change against log-counts per million, with DE genes highlighted:
plotMD(et) %>%
  abline(h=c(-1, 1), col="blue") #The blue lines indicate 2-fold changes

#Plot heatmap
heatmap(y$pseudo.counts, margins = c(10,5))

#Save the heatmap as a png file

png(filename='heatmap.png', width=800, height=1100)

heatmap(y$pseudo.counts)

graphics.off()        

#Make a basic volcano plot
with(x,plot(logFC,-log10(PValue),pch=20,main="Volcanoplot"))

# Change the color of the DE genes at FDR = 0.05 and logFC > 2 to orange
with(subset(x,FDR<.05 & abs(logFC)>2),points(logFC,-log10(PValue), pch=20,col="orange"))

### Output DE genes: ###

# Matrix of significantly DE genes
mat <- cbind(
  
  genes,
  sprintf('%0.3f', et$table$PValue),
  sprintf('%0.3f',et$table$logFC)
  
)[as.logical(deg),]

# Rename the columns of the data frame
colnames(mat) <- c("Gene", "Pvalue", "Log_fold_change")

# Order by log fold change
mat <- as_tibble(mat) %>%
  mutate(Log_fold_change = as.numeric(Log_fold_change)) %>%
  arrange( desc(Log_fold_change) )

## Keep only DEGs with a log of the fold change > 2 (either up- or down-regulated)
mat <- mat %>%
  dplyr::filter( abs(`Log_fold_change`) > 2 )

# Save the table containing all DE genes
write.csv(mat, file="DE_Genes.csv", quote=FALSE, row.names=FALSE)
